/* Generated by JTB 1.4.6 */
package org.mentalsmash.whadl.parser.visitor;

import org.mentalsmash.whadl.parser.nodes.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "RetArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <R> The user return information type
 * @param <A> The user argument type
 */
public class DepthFirstRetArguVisitor<R, A> implements IRetArguVisitor<R, A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeChoice n, final A argu) {
    final R nRes = n.choice.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeList n, final A argu) {
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeListOptional n, final A argu) {
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this, argu);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeOptional n, final A argu) {
    if (n.present()) {
      final R nRes = n.node.accept(this, argu);
      return nRes;
    } else
    return null;
  }

  /**
   * Visits a {@link NodeSequence} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeSequence n, final A argu) {
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link ArmyDefinition} node, whose children are the following :
   * <p>
   * f0 -> < ARMY ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> [ #0 < LCP ><br>
   * .. .. . #1 ( ArmyEntry() )+ #2 < RCP > ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ArmyDefinition n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence n2Seq = (NodeSequence) n2.node;
      final INode n2SeqA0 = n2Seq.elementAt(0);
      nRes = n2SeqA0.accept(this, argu);
      final INode n2SeqA1 = n2Seq.elementAt(1);
      final NodeList n2SeqA1Lst = (NodeList) n2SeqA1;
      for (int i = 0; i < n2SeqA1Lst.size(); i++) {
        final INode n2SeqA1LstEi = n2SeqA1Lst.elementAt(i);
        nRes = n2SeqA1LstEi.accept(this, argu);
      }
      final INode n2SeqA2 = n2Seq.elementAt(2);
      nRes = n2SeqA2.accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link ArmyEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitDefinition()<br>
   * .. .. | %1 Conditions()<br>
   * .. .. | %2 Extends()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ArmyEntry n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Conditions} node, whose children are the following :
   * <p>
   * f0 -> < CONDITIONS ><br>
   * f1 -> < LP ><br>
   * f2 -> Expression()<br>
   * f3 -> < RP ><br>
   * f4 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Conditions n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final Expression n2 = n.f2;
    nRes = n2.accept(this, argu);
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Extends} node, whose children are the following :
   * <p>
   * f0 -> < EXTENDS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Extends n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitDefinition} node, whose children are the following :
   * <p>
   * f0 -> < UNIT ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LCP ><br>
   * f3 -> ( UnitEntry() )+<br>
   * f4 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitDefinition n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    final NodeList n3 = n.f3;
    for (int i = 0; i < n3.size(); i++) {
      final INode n3Ei = n3.elementAt(i);
      nRes = n3Ei.accept(this, argu);
    }
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitSlotEntry()<br>
   * .. .. | %1 UnitBaseCostEntry()<br>
   * .. .. | %2 UnitCompositionEntry()<br>
   * .. .. | %3 UnitMemberEntry()<br>
   * .. .. | %4 UnitUpgradesEntry()<br>
   * .. .. | %5 UnitSpecialsEntry()<br>
   * .. .. | %6 UnitLinkedUnitsEntry()<br>
   * .. .. | %7 Extends()<br>
   * .. .. | %8 Conditions()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitEntry n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      case 3:
        nRes = n0ChN.accept(this, argu);
        break;
      case 4:
        nRes = n0ChN.accept(this, argu);
        break;
      case 5:
        nRes = n0ChN.accept(this, argu);
        break;
      case 6:
        nRes = n0ChN.accept(this, argu);
        break;
      case 7:
        nRes = n0ChN.accept(this, argu);
        break;
      case 8:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link UnitLinkedUnitsEntry} node, whose children are the following :
   * <p>
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitLinkedUnitsEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitSlotEntry} node, whose children are the following :
   * <p>
   * f0 -> < SLOTS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitSlotEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitBaseCostEntry} node, whose children are the following :
   * <p>
   * f0 -> < COST ><br>
   * f1 -> Expression()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitBaseCostEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Expression n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitCompositionEntry} node, whose children are the following :
   * <p>
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitCompositionEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitUpgradesEntry} node, whose children are the following :
   * <p>
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitUpgradesEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitSpecialsEntry} node, whose children are the following :
   * <p>
   * f0 -> < SPECIAL ><br>
   * f1 -> < LCP ><br>
   * f2 -> ( %0 UnitDefinition()<br>
   * .. .. | %1 Conditions() )*<br>
   * f3 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitSpecialsEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode n2Ei = n2.elementAt(i);
        final NodeChoice n2EiCh = (NodeChoice) n2Ei;
        final INode n2EiChN = n2EiCh.choice;
        switch (n2EiCh.which) {
          case 0:
            nRes = n2EiChN.accept(this, argu);
            break;
          case 1:
            nRes = n2EiChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
      }
    }
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitMemberEntry} node, whose children are the following :
   * <p>
   * f0 -> < MEMBER ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( %0 #0 < LCP ><br>
   * .. .. #1 ( UnitMemberDefEntry() )* #2 < RCP ><br>
   * .. .. | %1 < SEMICOLON > )<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitMemberEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeChoice n2 = n.f2;
    final INode n2N = n2.choice;
    switch (n2.which) {
      case 0:
        final NodeSequence n2NSeq0 = (NodeSequence) n2N;
        final INode n2NSeq0A0 = n2NSeq0.elementAt(0);
        nRes = n2NSeq0A0.accept(this, argu);
        final INode n2NSeq0A1 = n2NSeq0.elementAt(1);
        final NodeListOptional n2NSeq0A1Nlo = (NodeListOptional) n2NSeq0A1;
        if (n2NSeq0A1Nlo.present()) {
          for (int i = 0; i < n2NSeq0A1Nlo.size(); i++) {
            final INode n2NSeq0A1NloEi = n2NSeq0A1Nlo.elementAt(i);
            nRes = n2NSeq0A1NloEi.accept(this, argu);
          }
        }
        final INode n2NSeq0A2 = n2NSeq0.elementAt(2);
        nRes = n2NSeq0A2.accept(this, argu);
        break;
      case 1:
        nRes = n2N.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link UnitMemberDefEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 MemberEquipmentEntry()<br>
   * .. .. | %1 Extends()<br>
   * .. .. | %2 Conditions()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitMemberDefEntry n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link MemberEquipmentEntry} node, whose children are the following :
   * <p>
   * f0 -> < EQUIPMENT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final MemberEquipmentEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ArmyBuildDefinition} node, whose children are the following :
   * <p>
   * f0 -> < BUILD ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> ( UnitInstanceDefinition() )*<br>
   * f5 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ArmyBuildDefinition n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence n2Seq = (NodeSequence) n2.node;
      final INode n2SeqA0 = n2Seq.elementAt(0);
      nRes = n2SeqA0.accept(this, argu);
      final INode n2SeqA1 = n2Seq.elementAt(1);
      nRes = n2SeqA1.accept(this, argu);
    }
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    final NodeListOptional n4 = n.f4;
    if (n4.present()) {
      for (int i = 0; i < n4.size(); i++) {
        final INode n4Ei = n4.elementAt(i);
        nRes = n4Ei.accept(this, argu);
      }
    }
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ArmyBuildEntries} node, whose children are the following :
   * <p>
   * f0 -> < ARMY ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   * f3 -> ( UnitInstanceDefinition() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ArmyBuildEntries n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Reference n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    final NodeListOptional n3 = n.f3;
    if (n3.present()) {
      for (int i = 0; i < n3.size(); i++) {
        final INode n3Ei = n3.elementAt(i);
        nRes = n3Ei.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceDefinition} node, whose children are the following :
   * <p>
   * f0 -> < UNIT ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> ( UnitInstanceEntry() )*<br>
   * f5 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceDefinition n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence n2Seq = (NodeSequence) n2.node;
      final INode n2SeqA0 = n2Seq.elementAt(0);
      nRes = n2SeqA0.accept(this, argu);
      final INode n2SeqA1 = n2Seq.elementAt(1);
      nRes = n2SeqA1.accept(this, argu);
    }
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    final NodeListOptional n4 = n.f4;
    if (n4.present()) {
      for (int i = 0; i < n4.size(); i++) {
        final INode n4Ei = n4.elementAt(i);
        nRes = n4Ei.accept(this, argu);
      }
    }
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitInstanceSlotEntry()<br>
   * .. .. | %1 UnitInstanceCompositionEntry()<br>
   * .. .. | %2 UnitInstanceLinkedEntry()<br>
   * .. .. | %3 UnitInstanceUpgradesEntry()<br>
   * .. .. | %4 UnitMemberInstanceEntry()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceEntry n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      case 3:
        nRes = n0ChN.accept(this, argu);
        break;
      case 4:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceTypeEntry} node, whose children are the following :
   * <p>
   * f0 -> < TYPE ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceTypeEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Reference n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceSlotEntry} node, whose children are the following :
   * <p>
   * f0 -> < SLOT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceSlotEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceLinkedEntry} node, whose children are the following :
   * <p>
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceLinkedEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceCompositionEntry} node, whose children are the following :
   * <p>
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceCompositionEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitInstanceUpgradesEntry} node, whose children are the following :
   * <p>
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitInstanceUpgradesEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnitMemberInstanceEntry} node, whose children are the following :
   * <p>
   * f0 -> < MEMBER ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LP ><br>
   * f4 -> Pattern()<br>
   * f5 -> < RP ><br>
   * f6 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnitMemberInstanceEntry n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final Pattern n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence n2Seq = (NodeSequence) n2.node;
      final INode n2SeqA0 = n2Seq.elementAt(0);
      nRes = n2SeqA0.accept(this, argu);
      final INode n2SeqA1 = n2Seq.elementAt(1);
      nRes = n2SeqA1.accept(this, argu);
    }
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    final Pattern n4 = n.f4;
    nRes = n4.accept(this, argu);
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    final NodeToken n6 = n.f6;
    nRes = n6.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Pattern} node, whose children are the following :
   * <p>
   * f0 -> SetPatternExpr()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Pattern n, final A argu) {
    R nRes = null;
    final SetPatternExpr n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link SetPatternExpr} node, whose children are the following :
   * <p>
   * f0 -> AlternativeSetExpr()<br>
   * f1 -> ( #0 < COMMA > #1 AlternativeSetExpr() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final SetPatternExpr n, final A argu) {
    R nRes = null;
    final AlternativeSetExpr n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        nRes = n1EiSeqA0.accept(this, argu);
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link AlternativeSetExpr} node, whose children are the following :
   * <p>
   * f0 -> SinglePatternExpr()<br>
   * f1 -> ( #0 < OR > #1 SinglePatternExpr() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final AlternativeSetExpr n, final A argu) {
    R nRes = null;
    final SinglePatternExpr n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        nRes = n1EiSeqA0.accept(this, argu);
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link SinglePatternExpr} node, whose children are the following :
   * <p>
   * f0 -> . %0 SingleEntityPatternExpr()<br>
   * .. .. | %1 #0 < LP > #1 Pattern() #2 < RP ><br>
   * .. .. | %2 #0 < LB > #1 Pattern() #2 < RB ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final SinglePatternExpr n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        final NodeSequence n0ChNSeq1 = (NodeSequence) n0ChN;
        final INode n0ChNSeq1A0 = n0ChNSeq1.elementAt(0);
        nRes = n0ChNSeq1A0.accept(this, argu);
        final INode n0ChNSeq1A1 = n0ChNSeq1.elementAt(1);
        nRes = n0ChNSeq1A1.accept(this, argu);
        final INode n0ChNSeq1A2 = n0ChNSeq1.elementAt(2);
        nRes = n0ChNSeq1A2.accept(this, argu);
        break;
      case 2:
        final NodeSequence n0ChNSeq2 = (NodeSequence) n0ChN;
        final INode n0ChNSeq2A0 = n0ChNSeq2.elementAt(0);
        nRes = n0ChNSeq2A0.accept(this, argu);
        final INode n0ChNSeq2A1 = n0ChNSeq2.elementAt(1);
        nRes = n0ChNSeq2A1.accept(this, argu);
        final INode n0ChNSeq2A2 = n0ChNSeq2.elementAt(2);
        nRes = n0ChNSeq2A2.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link SingleEntityPatternExpr} node, whose children are the following :
   * <p>
   * f0 -> [ Quantifier() ]<br>
   * f1 -> Reference()<br>
   * f2 -> [ #0 < FOR > #1 Expression() ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final SingleEntityPatternExpr n, final A argu) {
    R nRes = null;
    final NodeOptional n0 = n.f0;
    if (n0.present()) {
      nRes = n0.accept(this, argu);
    }
    final Reference n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence n2Seq = (NodeSequence) n2.node;
      final INode n2SeqA0 = n2Seq.elementAt(0);
      nRes = n2SeqA0.accept(this, argu);
      final INode n2SeqA1 = n2Seq.elementAt(1);
      nRes = n2SeqA1.accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link Quantifier} node, whose children are the following :
   * <p>
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 "*"<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Quantifier n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Expression} node, whose children are the following :
   * <p>
   * f0 -> . %0 ConditionalExpression()<br>
   * .. .. | %1 LabeledExpression()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Expression n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link LabeledExpression} node, whose children are the following :
   * <p>
   * f0 -> "#"<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LP ><br>
   * f3 -> ConditionalExpression()<br>
   * f4 -> < RP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final LabeledExpression n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    final ConditionalExpression n3 = n.f3;
    nRes = n3.accept(this, argu);
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ConditionalExpression} node, whose children are the following :
   * <p>
   * f0 -> LogicalOrExpression()<br>
   * f1 -> [ #0 "?" #1 Expression() #2 ":" #3 Expression() ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ConditionalExpression n, final A argu) {
    R nRes = null;
    final LogicalOrExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeOptional n1 = n.f1;
    if (n1.present()) {
      final NodeSequence n1Seq = (NodeSequence) n1.node;
      final INode n1SeqA0 = n1Seq.elementAt(0);
      nRes = n1SeqA0.accept(this, argu);
      final INode n1SeqA1 = n1Seq.elementAt(1);
      nRes = n1SeqA1.accept(this, argu);
      final INode n1SeqA2 = n1Seq.elementAt(2);
      nRes = n1SeqA2.accept(this, argu);
      final INode n1SeqA3 = n1Seq.elementAt(3);
      nRes = n1SeqA3.accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link LogicalOrExpression} node, whose children are the following :
   * <p>
   * f0 -> LogicalAndExpression()<br>
   * f1 -> ( #0 "||" #1 LogicalAndExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final LogicalOrExpression n, final A argu) {
    R nRes = null;
    final LogicalAndExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        nRes = n1EiSeqA0.accept(this, argu);
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link LogicalAndExpression} node, whose children are the following :
   * <p>
   * f0 -> EqualityExpression()<br>
   * f1 -> ( #0 "&&" #1 EqualityExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final LogicalAndExpression n, final A argu) {
    R nRes = null;
    final EqualityExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        nRes = n1EiSeqA0.accept(this, argu);
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link EqualityExpression} node, whose children are the following :
   * <p>
   * f0 -> RelationalExpression()<br>
   * f1 -> ( #0 ( %0 "=="<br>
   * .. .. . .. | %1 "!=" ) #1 RelationalExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final EqualityExpression n, final A argu) {
    R nRes = null;
    final RelationalExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeChoice n1EiSeqA0Ch = (NodeChoice) n1EiSeqA0;
        final INode n1EiSeqA0ChN = n1EiSeqA0Ch.choice;
        switch (n1EiSeqA0Ch.which) {
          case 0:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link RelationalExpression} node, whose children are the following :
   * <p>
   * f0 -> AdditiveExpression()<br>
   * f1 -> ( #0 ( %0 "<"<br>
   * .. .. . .. | %1 ">"<br>
   * .. .. . .. | %2 "<="<br>
   * .. .. . .. | %3 ">=" ) #1 AdditiveExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final RelationalExpression n, final A argu) {
    R nRes = null;
    final AdditiveExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeChoice n1EiSeqA0Ch = (NodeChoice) n1EiSeqA0;
        final INode n1EiSeqA0ChN = n1EiSeqA0Ch.choice;
        switch (n1EiSeqA0Ch.which) {
          case 0:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 2:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 3:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * f0 -> MultiplicativeExpression()<br>
   * f1 -> ( #0 ( %0 "+"<br>
   * .. .. . .. | %1 "-" ) #1 MultiplicativeExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final AdditiveExpression n, final A argu) {
    R nRes = null;
    final MultiplicativeExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeChoice n1EiSeqA0Ch = (NodeChoice) n1EiSeqA0;
        final INode n1EiSeqA0ChN = n1EiSeqA0Ch.choice;
        switch (n1EiSeqA0Ch.which) {
          case 0:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link MultiplicativeExpression} node, whose children are the following :
   * <p>
   * f0 -> CollectionOperationExpression()<br>
   * f1 -> ( #0 ( %0 "*"<br>
   * .. .. . .. | %1 "/" ) #1 CollectionOperationExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final MultiplicativeExpression n, final A argu) {
    R nRes = null;
    final CollectionOperationExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeChoice n1EiSeqA0Ch = (NodeChoice) n1EiSeqA0;
        final INode n1EiSeqA0ChN = n1EiSeqA0Ch.choice;
        switch (n1EiSeqA0Ch.which) {
          case 0:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link CollectionOperationExpression} node, whose children are the following :
   * <p>
   * f0 -> UnaryExpression()<br>
   * f1 -> ( #0 ( %0 < CONTAINS ><br>
   * .. .. . .. | %1 < UNION ><br>
   * .. .. . .. | %2 < INTERS ><br>
   * .. .. . .. | %3 < SELECT ><br>
   * .. .. . .. | %4 < EACH > ) #1 UnaryExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final CollectionOperationExpression n, final A argu) {
    R nRes = null;
    final UnaryExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeChoice n1EiSeqA0Ch = (NodeChoice) n1EiSeqA0;
        final INode n1EiSeqA0ChN = n1EiSeqA0Ch.choice;
        switch (n1EiSeqA0Ch.which) {
          case 0:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 2:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 3:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          case 4:
            nRes = n1EiSeqA0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link UnaryExpression} node, whose children are the following :
   * <p>
   * f0 -> . %0 #0 ( &0 "+"<br>
   * .. .. . .. .. | &1 "-" ) #1 UnaryExpression()<br>
   * .. .. | %1 UnaryExpressionNotPlusMinus()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnaryExpression n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        final NodeSequence n0ChNSeq0 = (NodeSequence) n0ChN;
        final INode n0ChNSeq0A0 = n0ChNSeq0.elementAt(0);
        final NodeChoice n0ChNSeq0A0Ch = (NodeChoice) n0ChNSeq0A0;
        final INode n0ChNSeq0A0ChN = n0ChNSeq0A0Ch.choice;
        switch (n0ChNSeq0A0Ch.which) {
          case 0:
            nRes = n0ChNSeq0A0ChN.accept(this, argu);
            break;
          case 1:
            nRes = n0ChNSeq0A0ChN.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        final INode n0ChNSeq0A1 = n0ChNSeq0.elementAt(1);
        nRes = n0ChNSeq0A1.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link UnaryExpressionNotPlusMinus} node, whose children are the following :
   * <p>
   * f0 -> . %0 #0 "!" #1 UnaryExpression()<br>
   * .. .. | %1 PrimaryExpression()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final UnaryExpressionNotPlusMinus n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        final NodeSequence n0ChNSeq0 = (NodeSequence) n0ChN;
        final INode n0ChNSeq0A0 = n0ChNSeq0.elementAt(0);
        nRes = n0ChNSeq0A0.accept(this, argu);
        final INode n0ChNSeq0A1 = n0ChNSeq0.elementAt(1);
        nRes = n0ChNSeq0A1.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link PrimaryExpression} node, whose children are the following :
   * <p>
   * f0 -> ( %0 Literal()<br>
   * .. .. | %1 #0 < LP > #1 Expression() #2 < RP ><br>
   * .. .. | %2 Reference() )<br>
   * f1 -> ( #0 < ARROW > #1 AttributeSelector() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final PrimaryExpression n, final A argu) {
    R nRes = null;
    final NodeChoice n0 = n.f0;
    final INode n0N = n0.choice;
    switch (n0.which) {
      case 0:
        nRes = n0N.accept(this, argu);
        break;
      case 1:
        final NodeSequence n0NSeq1 = (NodeSequence) n0N;
        final INode n0NSeq1A0 = n0NSeq1.elementAt(0);
        nRes = n0NSeq1A0.accept(this, argu);
        final INode n0NSeq1A1 = n0NSeq1.elementAt(1);
        nRes = n0NSeq1A1.accept(this, argu);
        final INode n0NSeq1A2 = n0NSeq1.elementAt(2);
        nRes = n0NSeq1A2.accept(this, argu);
        break;
      case 2:
        nRes = n0N.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        nRes = n1EiSeqA0.accept(this, argu);
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link AttributeSelector} node, whose children are the following :
   * <p>
   * f0 -> . %00 < ARMY ><br>
   * .. .. | %01 < UNIT ><br>
   * .. .. | %02 < EQUIPMENT ><br>
   * .. .. | %03 < MEMBERS ><br>
   * .. .. | %04 < UPGRADES ><br>
   * .. .. | %05 < COST ><br>
   * .. .. | %06 < SLOTS ><br>
   * .. .. | %07 < TYPE ><br>
   * .. .. | %08 < UNITS ><br>
   * .. .. | %09 < LINKED ><br>
   * .. .. | %10 < IDENTIFIER ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final AttributeSelector n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      case 3:
        nRes = n0ChN.accept(this, argu);
        break;
      case 4:
        nRes = n0ChN.accept(this, argu);
        break;
      case 5:
        nRes = n0ChN.accept(this, argu);
        break;
      case 6:
        nRes = n0ChN.accept(this, argu);
        break;
      case 7:
        nRes = n0ChN.accept(this, argu);
        break;
      case 8:
        nRes = n0ChN.accept(this, argu);
        break;
      case 9:
        nRes = n0ChN.accept(this, argu);
        break;
      case 10:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Literal} node, whose children are the following :
   * <p>
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 < STRING_LITERAL ><br>
   * .. .. | %2 BooleanLiteral()<br>
   * .. .. | %3 CollectionLiteral()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Literal n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      case 2:
        nRes = n0ChN.accept(this, argu);
        break;
      case 3:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link BooleanLiteral} node, whose children are the following :
   * <p>
   * f0 -> . %0 < TRUE ><br>
   * .. .. | %1 < FALSE ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final BooleanLiteral n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.f0;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link CollectionLiteral} node, whose children are the following :
   * <p>
   * f0 -> < LCP ><br>
   * f1 -> [ #0 Expression()<br>
   * .. .. . #1 ( $0 < COMMA > $1 Expression() )* ]<br>
   * f2 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final CollectionLiteral n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    final NodeOptional n1 = n.f1;
    if (n1.present()) {
      final NodeSequence n1Seq = (NodeSequence) n1.node;
      final INode n1SeqA0 = n1Seq.elementAt(0);
      nRes = n1SeqA0.accept(this, argu);
      final INode n1SeqA1 = n1Seq.elementAt(1);
      final NodeListOptional n1SeqA1Nlo = (NodeListOptional) n1SeqA1;
      if (n1SeqA1Nlo.present()) {
        for (int i = 0; i < n1SeqA1Nlo.size(); i++) {
          final INode n1SeqA1NloEi = n1SeqA1Nlo.elementAt(i);
          final NodeSequence n1SeqA1NloEiSeq = (NodeSequence) n1SeqA1NloEi;
          final INode n1SeqA1NloEiSeqA0 = n1SeqA1NloEiSeq.elementAt(0);
          nRes = n1SeqA1NloEiSeqA0.accept(this, argu);
          final INode n1SeqA1NloEiSeqA1 = n1SeqA1NloEiSeq.elementAt(1);
          nRes = n1SeqA1NloEiSeqA1.accept(this, argu);
        }
      }
    }
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Reference} node, whose children are the following :
   * <p>
   * f0 -> [ "$" ]<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( #0 "." #1 < IDENTIFIER > )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Reference n, final A argu) {
    R nRes = null;
    final NodeOptional n0 = n.f0;
    if (n0.present()) {
      nRes = n0.accept(this, argu);
    }
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode n2Ei = n2.elementAt(i);
        final NodeSequence n2EiSeq = (NodeSequence) n2Ei;
        final INode n2EiSeqA0 = n2EiSeq.elementAt(0);
        nRes = n2EiSeqA0.accept(this, argu);
        final INode n2EiSeqA1 = n2EiSeq.elementAt(1);
        nRes = n2EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

}
