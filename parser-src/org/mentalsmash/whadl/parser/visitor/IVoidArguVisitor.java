/* Generated by JTB 1.4.6 */
package org.mentalsmash.whadl.parser.visitor;

import org.mentalsmash.whadl.parser.nodes.*;

/**
 * All "VoidArgu" visitors must implement this interface.
 * @param <A> The user argument type
 */
public interface IVoidArguVisitor<A> {

  /*
   * Base "VoidArgu" visit methods
   */

  /**
   * Visits a {@link NodeList} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final NodeList n, final A argu);

  /**
   * Visits a {@link NodeListOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final NodeListOptional n, final A argu);

  /**
   * Visits a {@link NodeOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final NodeOptional n, final A argu);


  /**
   * Visits a {@link NodeSequence} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final NodeSequence n, final A argu);

  /**
   * Visits a {@link NodeToken} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final NodeToken n, final A argu);

  /*
   * User grammar generated visit methods
   */

  /**
   * Visits a {@link ArmyDefinition} node, whose children are the following :
   * <p>
   * f0 -> < ARMY ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> [ #0 < LCP ><br>
   * .. .. . #1 ( ArmyEntry() )+ #2 < RCP > ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final ArmyDefinition n, final A argu);

  /**
   * Visits a {@link ArmyEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitDefinition()<br>
   * .. .. | %1 Conditions()<br>
   * .. .. | %2 Extends()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final ArmyEntry n, final A argu);

  /**
   * Visits a {@link Conditions} node, whose children are the following :
   * <p>
   * f0 -> < CONDITIONS ><br>
   * f1 -> < LP ><br>
   * f2 -> Expression()<br>
   * f3 -> < RP ><br>
   * f4 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Conditions n, final A argu);

  /**
   * Visits a {@link Extends} node, whose children are the following :
   * <p>
   * f0 -> < EXTENDS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Extends n, final A argu);

  /**
   * Visits a {@link UnitDefinition} node, whose children are the following :
   * <p>
   * f0 -> < UNIT ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LCP ><br>
   * f3 -> ( UnitEntry() )+<br>
   * f4 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitDefinition n, final A argu);

  /**
   * Visits a {@link UnitEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitSlotEntry()<br>
   * .. .. | %1 UnitBaseCostEntry()<br>
   * .. .. | %2 UnitCompositionEntry()<br>
   * .. .. | %3 UnitMemberEntry()<br>
   * .. .. | %4 UnitUpgradesEntry()<br>
   * .. .. | %5 UnitSpecialsEntry()<br>
   * .. .. | %6 UnitLinkedUnitsEntry()<br>
   * .. .. | %7 Extends()<br>
   * .. .. | %8 Conditions()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitEntry n, final A argu);

  /**
   * Visits a {@link UnitLinkedUnitsEntry} node, whose children are the following :
   * <p>
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitLinkedUnitsEntry n, final A argu);

  /**
   * Visits a {@link UnitSlotEntry} node, whose children are the following :
   * <p>
   * f0 -> < SLOTS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitSlotEntry n, final A argu);

  /**
   * Visits a {@link UnitBaseCostEntry} node, whose children are the following :
   * <p>
   * f0 -> < COST ><br>
   * f1 -> Expression()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitBaseCostEntry n, final A argu);

  /**
   * Visits a {@link UnitCompositionEntry} node, whose children are the following :
   * <p>
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitCompositionEntry n, final A argu);

  /**
   * Visits a {@link UnitUpgradesEntry} node, whose children are the following :
   * <p>
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitUpgradesEntry n, final A argu);

  /**
   * Visits a {@link UnitSpecialsEntry} node, whose children are the following :
   * <p>
   * f0 -> < SPECIAL ><br>
   * f1 -> < LCP ><br>
   * f2 -> ( %0 UnitDefinition()<br>
   * .. .. | %1 Conditions() )*<br>
   * f3 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitSpecialsEntry n, final A argu);

  /**
   * Visits a {@link UnitMemberEntry} node, whose children are the following :
   * <p>
   * f0 -> < MEMBER ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( %0 #0 < LCP ><br>
   * .. .. #1 ( UnitMemberDefEntry() )* #2 < RCP ><br>
   * .. .. | %1 < SEMICOLON > )<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitMemberEntry n, final A argu);

  /**
   * Visits a {@link UnitMemberDefEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 MemberEquipmentEntry()<br>
   * .. .. | %1 Extends()<br>
   * .. .. | %2 Conditions()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitMemberDefEntry n, final A argu);

  /**
   * Visits a {@link MemberEquipmentEntry} node, whose children are the following :
   * <p>
   * f0 -> < EQUIPMENT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final MemberEquipmentEntry n, final A argu);

  /**
   * Visits a {@link ArmyBuildDefinition} node, whose children are the following :
   * <p>
   * f0 -> < BUILD ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> ( UnitInstanceDefinition() )*<br>
   * f5 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final ArmyBuildDefinition n, final A argu);

  /**
   * Visits a {@link ArmyBuildEntries} node, whose children are the following :
   * <p>
   * f0 -> < ARMY ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   * f3 -> ( UnitInstanceDefinition() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final ArmyBuildEntries n, final A argu);

  /**
   * Visits a {@link UnitInstanceDefinition} node, whose children are the following :
   * <p>
   * f0 -> < UNIT ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> ( UnitInstanceEntry() )*<br>
   * f5 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceDefinition n, final A argu);

  /**
   * Visits a {@link UnitInstanceEntry} node, whose children are the following :
   * <p>
   * f0 -> . %0 UnitInstanceSlotEntry()<br>
   * .. .. | %1 UnitInstanceCompositionEntry()<br>
   * .. .. | %2 UnitInstanceLinkedEntry()<br>
   * .. .. | %3 UnitInstanceUpgradesEntry()<br>
   * .. .. | %4 UnitMemberInstanceEntry()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceEntry n, final A argu);

  /**
   * Visits a {@link UnitInstanceTypeEntry} node, whose children are the following :
   * <p>
   * f0 -> < TYPE ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceTypeEntry n, final A argu);

  /**
   * Visits a {@link UnitInstanceSlotEntry} node, whose children are the following :
   * <p>
   * f0 -> < SLOT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceSlotEntry n, final A argu);

  /**
   * Visits a {@link UnitInstanceLinkedEntry} node, whose children are the following :
   * <p>
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceLinkedEntry n, final A argu);

  /**
   * Visits a {@link UnitInstanceCompositionEntry} node, whose children are the following :
   * <p>
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceCompositionEntry n, final A argu);

  /**
   * Visits a {@link UnitInstanceUpgradesEntry} node, whose children are the following :
   * <p>
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitInstanceUpgradesEntry n, final A argu);

  /**
   * Visits a {@link UnitMemberInstanceEntry} node, whose children are the following :
   * <p>
   * f0 -> < MEMBER ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LP ><br>
   * f4 -> Pattern()<br>
   * f5 -> < RP ><br>
   * f6 -> < SEMICOLON ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnitMemberInstanceEntry n, final A argu);

  /**
   * Visits a {@link Pattern} node, whose children are the following :
   * <p>
   * f0 -> SetPatternExpr()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Pattern n, final A argu);

  /**
   * Visits a {@link SetPatternExpr} node, whose children are the following :
   * <p>
   * f0 -> AlternativeSetExpr()<br>
   * f1 -> ( #0 < COMMA > #1 AlternativeSetExpr() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final SetPatternExpr n, final A argu);

  /**
   * Visits a {@link AlternativeSetExpr} node, whose children are the following :
   * <p>
   * f0 -> SinglePatternExpr()<br>
   * f1 -> ( #0 < OR > #1 SinglePatternExpr() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final AlternativeSetExpr n, final A argu);

  /**
   * Visits a {@link SinglePatternExpr} node, whose children are the following :
   * <p>
   * f0 -> . %0 SingleEntityPatternExpr()<br>
   * .. .. | %1 #0 < LP > #1 Pattern() #2 < RP ><br>
   * .. .. | %2 #0 < LB > #1 Pattern() #2 < RB ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final SinglePatternExpr n, final A argu);

  /**
   * Visits a {@link SingleEntityPatternExpr} node, whose children are the following :
   * <p>
   * f0 -> [ Quantifier() ]<br>
   * f1 -> Reference()<br>
   * f2 -> [ #0 < FOR > #1 Expression() ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final SingleEntityPatternExpr n, final A argu);

  /**
   * Visits a {@link Quantifier} node, whose children are the following :
   * <p>
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 "*"<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Quantifier n, final A argu);

  /**
   * Visits a {@link Expression} node, whose children are the following :
   * <p>
   * f0 -> . %0 ConditionalExpression()<br>
   * .. .. | %1 LabeledExpression()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Expression n, final A argu);

  /**
   * Visits a {@link LabeledExpression} node, whose children are the following :
   * <p>
   * f0 -> "#"<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LP ><br>
   * f3 -> ConditionalExpression()<br>
   * f4 -> < RP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final LabeledExpression n, final A argu);

  /**
   * Visits a {@link ConditionalExpression} node, whose children are the following :
   * <p>
   * f0 -> LogicalOrExpression()<br>
   * f1 -> [ #0 "?" #1 Expression() #2 ":" #3 Expression() ]<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final ConditionalExpression n, final A argu);

  /**
   * Visits a {@link LogicalOrExpression} node, whose children are the following :
   * <p>
   * f0 -> LogicalAndExpression()<br>
   * f1 -> ( #0 "||" #1 LogicalAndExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final LogicalOrExpression n, final A argu);

  /**
   * Visits a {@link LogicalAndExpression} node, whose children are the following :
   * <p>
   * f0 -> EqualityExpression()<br>
   * f1 -> ( #0 "&&" #1 EqualityExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final LogicalAndExpression n, final A argu);

  /**
   * Visits a {@link EqualityExpression} node, whose children are the following :
   * <p>
   * f0 -> RelationalExpression()<br>
   * f1 -> ( #0 ( %0 "=="<br>
   * .. .. . .. | %1 "!=" ) #1 RelationalExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final EqualityExpression n, final A argu);

  /**
   * Visits a {@link RelationalExpression} node, whose children are the following :
   * <p>
   * f0 -> AdditiveExpression()<br>
   * f1 -> ( #0 ( %0 "<"<br>
   * .. .. . .. | %1 ">"<br>
   * .. .. . .. | %2 "<="<br>
   * .. .. . .. | %3 ">=" ) #1 AdditiveExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final RelationalExpression n, final A argu);

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * f0 -> MultiplicativeExpression()<br>
   * f1 -> ( #0 ( %0 "+"<br>
   * .. .. . .. | %1 "-" ) #1 MultiplicativeExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final AdditiveExpression n, final A argu);

  /**
   * Visits a {@link MultiplicativeExpression} node, whose children are the following :
   * <p>
   * f0 -> CollectionOperationExpression()<br>
   * f1 -> ( #0 ( %0 "*"<br>
   * .. .. . .. | %1 "/" ) #1 CollectionOperationExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final MultiplicativeExpression n, final A argu);

  /**
   * Visits a {@link CollectionOperationExpression} node, whose children are the following :
   * <p>
   * f0 -> UnaryExpression()<br>
   * f1 -> ( #0 ( %0 < CONTAINS ><br>
   * .. .. . .. | %1 < UNION ><br>
   * .. .. . .. | %2 < INTERS ><br>
   * .. .. . .. | %3 < SELECT ><br>
   * .. .. . .. | %4 < EACH > ) #1 UnaryExpression() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final CollectionOperationExpression n, final A argu);

  /**
   * Visits a {@link UnaryExpression} node, whose children are the following :
   * <p>
   * f0 -> . %0 #0 ( &0 "+"<br>
   * .. .. . .. .. | &1 "-" ) #1 UnaryExpression()<br>
   * .. .. | %1 UnaryExpressionNotPlusMinus()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnaryExpression n, final A argu);

  /**
   * Visits a {@link UnaryExpressionNotPlusMinus} node, whose children are the following :
   * <p>
   * f0 -> . %0 #0 "!" #1 UnaryExpression()<br>
   * .. .. | %1 PrimaryExpression()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final UnaryExpressionNotPlusMinus n, final A argu);

  /**
   * Visits a {@link PrimaryExpression} node, whose children are the following :
   * <p>
   * f0 -> ( %0 Literal()<br>
   * .. .. | %1 #0 < LP > #1 Expression() #2 < RP ><br>
   * .. .. | %2 Reference() )<br>
   * f1 -> ( #0 < ARROW > #1 AttributeSelector() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final PrimaryExpression n, final A argu);

  /**
   * Visits a {@link AttributeSelector} node, whose children are the following :
   * <p>
   * f0 -> . %00 < ARMY ><br>
   * .. .. | %01 < UNIT ><br>
   * .. .. | %02 < EQUIPMENT ><br>
   * .. .. | %03 < MEMBERS ><br>
   * .. .. | %04 < UPGRADES ><br>
   * .. .. | %05 < COST ><br>
   * .. .. | %06 < SLOTS ><br>
   * .. .. | %07 < TYPE ><br>
   * .. .. | %08 < UNITS ><br>
   * .. .. | %09 < LINKED ><br>
   * .. .. | %10 < IDENTIFIER ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final AttributeSelector n, final A argu);

  /**
   * Visits a {@link Literal} node, whose children are the following :
   * <p>
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 < STRING_LITERAL ><br>
   * .. .. | %2 BooleanLiteral()<br>
   * .. .. | %3 CollectionLiteral()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Literal n, final A argu);

  /**
   * Visits a {@link BooleanLiteral} node, whose children are the following :
   * <p>
   * f0 -> . %0 < TRUE ><br>
   * .. .. | %1 < FALSE ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final BooleanLiteral n, final A argu);

  /**
   * Visits a {@link CollectionLiteral} node, whose children are the following :
   * <p>
   * f0 -> < LCP ><br>
   * f1 -> [ #0 Expression()<br>
   * .. .. . #1 ( $0 < COMMA > $1 Expression() )* ]<br>
   * f2 -> < RCP ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final CollectionLiteral n, final A argu);

  /**
   * Visits a {@link Reference} node, whose children are the following :
   * <p>
   * f0 -> [ "$" ]<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( #0 "." #1 < IDENTIFIER > )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   */
  public void visit(final Reference n, final A argu);

}
