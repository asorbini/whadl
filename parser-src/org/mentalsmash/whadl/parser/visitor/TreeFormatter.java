/* Generated by JTB 1.4.6 */
package org.mentalsmash.whadl.parser.visitor;

import java.util.ArrayList;
import java.util.Iterator;

import org.mentalsmash.whadl.parser.nodes.*;

/**
 * A skeleton output formatter for your language grammar.<br>
 * Using the add() method along with force(), indent(), and outdent(),<br>
 * you can easily specify how this visitor will format the given syntax tree.<br>
 * See the JTB documentation for more details.
 * <p>
 * Pass your syntax tree to this visitor, and then to the TreeDumper visitor<br>
 * in order to "pretty print" your tree.
 */
public class TreeFormatter extends DepthFirstVoidVisitor {

  /** The list of formatting commands */
  private final ArrayList<FormatCommand> cmdQueue = new ArrayList<FormatCommand>();
  /** True if line to be wrapped, false otherwise */
  private boolean lineWrap;
  /** The wrap width */
  private final int wrapWidth;
  /** The indentation amount */
  private final int indentAmt;
  /** The current line number */
  private int curLine = 1;
  /** The current column number */
  private int curColumn = 1;
  /** The current indentation */
  private int curIndent = 0;
  /** The default indentation */
  private static int INDENT_AMT = 2;

  /**
   * Constructor with a default indentation amount of {@link #INDENT_AMT} and no line-wrap.
   */
  public TreeFormatter() { this(INDENT_AMT, 0); }

  /**
   * Constructor using an indent amount and a line width used to wrap long lines.<br>
   * If a token's beginColumn value is greater than the specified wrapWidth,<br>
   * it will be moved to the next line andindented one extra level.<br>
   * To turn off line-wrapping, specify a wrapWidth of 0.
   *
   * @param aIndentAmt Amount of spaces per indentation level
   * @param aWrapWidth Wrap lines longer than wrapWidth. 0 for no wrap
   */
  public TreeFormatter(final int aIndentAmt, final int aWrapWidth) {
    this.indentAmt = aIndentAmt;
    this.wrapWidth = aWrapWidth;

    if (wrapWidth > 0)
       lineWrap = true;
    else
       lineWrap = false;
  }

  /**
   * Accepts a INodeList object.
   *
   * @param n the node list to process
   */
  protected void processList(final INodeList n) {
    processList(n, null);
  }

  /**
   * Accepts a INodeList object and performs a format command (if non null)<br>
   * between each node in the list (but not after the last node).
   *
   * @param n the node list to process
   * @param cmd the format command
   */
  protected void processList(final INodeList n, final FormatCommand cmd) {
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
       e.next().accept(this);
       if (cmd != null && e.hasNext())
        cmdQueue.add(cmd);
    }
  }

  /**
   * Inserts one line break and indents the next line to the current indentation level.<br>
   * Use "add(force());".
   *
   * @return the corresponding FormatCommand
   */
  protected FormatCommand force() { return force(1); }

  /**
   * Inserts a given number of line breaks and indents the next line to the current indentation level.<br>
   * Use "add(force(i));".
   *
   * @param i the number of line breaks
   * @return the corresponding FormatCommand
   */
  protected FormatCommand force(final int i) {
    return new FormatCommand(FormatCommand.FORCE, i);
  }

  /**
   * Increases the indentation level by one.<br>
   * Use "add(indent());".
   *
   * @return the corresponding FormatCommand
   */
  protected FormatCommand indent() { return indent(1); }

  /**
   * Increases the indentation level by a given number.<br>
   * Use "add(indent(i));".
   *
   * @param i the number of indentation levels to add
   * @return the corresponding FormatCommand
   */
  protected FormatCommand indent(final int i) {
    return new FormatCommand(FormatCommand.INDENT, i);
  }

  /**
   * Reduces the indentation level by one.<br>
   * Use "add(outdent());".
   *
   * @return the corresponding FormatCommand
   */
  protected FormatCommand outdent() { return outdent(1); }

  /**
   * Reduces the indentation level by a given number.<br>
   * Use "add(outdent(i));".
   *
   * @param i the number of indentation levels to substract
   * @return the corresponding FormatCommand
   */
  protected FormatCommand outdent(final int i) {
    return new FormatCommand(FormatCommand.OUTDENT, i);
  }

  /**
   * Adds one space between tokens.<br>
   * Use "add(space());".
   *
   * @return the corresponding FormatCommand
   */
  protected FormatCommand space() { return space(1); }

  /**
   * Adds a given number of spaces between tokens.<br>
   * Use "add(space(i));".
   *
   * @param i the number of spaces to add
   * @return the corresponding FormatCommand
   */
  protected FormatCommand space(final int i) {
    return new FormatCommand(FormatCommand.SPACE, i);
  }

  /**
   * Use this method to add FormatCommands to the command queue to be executed<br>
   * when the next token in the tree is visited.
   *
   * @param cmd the FormatCommand to be added
   */
  protected void add(final FormatCommand cmd) {
    cmdQueue.add(cmd);
  }

  /**
   * Executes the commands waiting in the command queue,<br>
   * then inserts the proper location information into the current NodeToken.
   * <p>
   * If there are any special tokens preceding this token,<br>
   * they will be given the current location information.<br>
   * The token will follow on the next line, at the proper indentation level.<br>
   * If this is not the behavior you want from special tokens,<br>
   * feel free to modify this method.
   */
  @Override
  public void visit(final NodeToken n) {
    for (Iterator<FormatCommand> e = cmdQueue.iterator(); e.hasNext();) {
      final FormatCommand cmd = e.next();
      switch (cmd.getCommand()) {
      case FormatCommand.FORCE :
        curLine += cmd.getNumCommands();
        curColumn = curIndent + 1;
        break;
      case FormatCommand.INDENT :
        curIndent += indentAmt * cmd.getNumCommands();
        break;
      case FormatCommand.OUTDENT :
        if (curIndent >= indentAmt)
        curIndent -= indentAmt * cmd.getNumCommands();
        break;
      case FormatCommand.SPACE :
        curColumn += cmd.getNumCommands();
        break;
      default :
        throw new TreeFormatterException("Invalid value in command queue.");
      }
    }

    cmdQueue.removeAll(cmdQueue);

    //
    // Handle all special tokens preceding this NodeToken
    //
    if (n.numSpecials() > 0)
      for (final Iterator<NodeToken> e = n.specialTokens.iterator(); e.hasNext();) {
       NodeToken special = e.next();

       //
       // Place the token
       // Move cursor to next line after the special token
       // Don't update curColumn - want to keep current indent level
       //
       placeToken(special, curLine, curColumn);
       curLine = special.endLine + 1;
      }

    placeToken(n, curLine, curColumn);
    curLine = n.endLine;
    curColumn = n.endColumn;
  }

  /**
   * Inserts token location (beginLine, beginColumn, endLine, endColumn)<br>
   * information into the NodeToken.<br>
   * Takes into account line-wrap. Does not update curLine and curColumn.
   *
   * @param n the NodeToken to insert
   * @param aLine the insertion line number
   * @param aColumn the insertion column number
   */
  private void placeToken(final NodeToken n, final int aLine, final int aColumn) {
    final int length = n.tokenImage.length();
    int line = aLine;
    int column = aColumn;

    //
    // Find beginning of token.  Only line-wrap for single-line tokens
    //
    if (!lineWrap || n.tokenImage.indexOf('\n') != -1 ||
       column + length <= wrapWidth)
       n.beginColumn = column;
    else {
       ++line;
       column = curIndent + indentAmt + 1;
       n.beginColumn = column;
    }

    n.beginLine = line;

    //
    // Find end of token; don't count '\n' if it's the last character
    //
    for (int i = 0; i < length; ++i) {
       if (n.tokenImage.charAt(i) == '\n' && i < length - 1) {
        ++line;
        column = 1;
       }
       else
        ++column;
    }

    n.endLine = line;
    n.endColumn = column;
  }

  //
  // User-generated visitor methods below
  //

  /**
   * f0 -> < ARMY ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> [ #0 < LCP ><br>
   * .. .. . #1 ( ArmyEntry() )+ #2 < RCP > ]<br>
   */
  @Override
  public void visit(final ArmyDefinition n) {
    n.f0.accept(this);
    n.f1.accept(this);
    if (n.f2.present()) {
      n.f2.accept(this);
    }
  }

  /**
   * f0 -> . %0 UnitDefinition()<br>
   * .. .. | %1 Conditions()<br>
   * .. .. | %2 Extends()<br>
   */
  @Override
  public void visit(final ArmyEntry n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> < CONDITIONS ><br>
   * f1 -> < LP ><br>
   * f2 -> Expression()<br>
   * f3 -> < RP ><br>
   * f4 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final Conditions n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
    n.f3.accept(this);
    n.f4.accept(this);
  }

  /**
   * f0 -> < EXTENDS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final Extends n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < UNIT ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LCP ><br>
   * f3 -> ( UnitEntry() )+<br>
   * f4 -> < RCP ><br>
   */
  @Override
  public void visit(final UnitDefinition n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
    processList(n.f3);
    n.f4.accept(this);
  }

  /**
   * f0 -> . %0 UnitSlotEntry()<br>
   * .. .. | %1 UnitBaseCostEntry()<br>
   * .. .. | %2 UnitCompositionEntry()<br>
   * .. .. | %3 UnitMemberEntry()<br>
   * .. .. | %4 UnitUpgradesEntry()<br>
   * .. .. | %5 UnitSpecialsEntry()<br>
   * .. .. | %6 UnitLinkedUnitsEntry()<br>
   * .. .. | %7 Extends()<br>
   * .. .. | %8 Conditions()<br>
   */
  @Override
  public void visit(final UnitEntry n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitLinkedUnitsEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < SLOTS ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitSlotEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < COST ><br>
   * f1 -> Expression()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitBaseCostEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitCompositionEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitUpgradesEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < SPECIAL ><br>
   * f1 -> < LCP ><br>
   * f2 -> ( %0 UnitDefinition()<br>
   * .. .. | %1 Conditions() )*<br>
   * f3 -> < RCP ><br>
   */
  @Override
  public void visit(final UnitSpecialsEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    if (n.f2.present()) {
      processList(n.f2);
    }
    n.f3.accept(this);
  }

  /**
   * f0 -> < MEMBER ><br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( %0 #0 < LCP ><br>
   * .. .. #1 ( UnitMemberDefEntry() )* #2 < RCP ><br>
   * .. .. | %1 < SEMICOLON > )<br>
   */
  @Override
  public void visit(final UnitMemberEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> . %0 MemberEquipmentEntry()<br>
   * .. .. | %1 Extends()<br>
   * .. .. | %2 Conditions()<br>
   */
  @Override
  public void visit(final UnitMemberDefEntry n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> < EQUIPMENT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final MemberEquipmentEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < BUILD ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> [ ArmyBuildEntries() ]<br>
   * f5 -> < RCP ><br>
   */
  @Override
  public void visit(final ArmyBuildDefinition n) {
    n.f0.accept(this);
    n.f1.accept(this);
    if (n.f2.present()) {
      n.f2.accept(this);
    }
    n.f3.accept(this);
    if (n.f4.present()) {
      n.f4.accept(this);
    }
    n.f5.accept(this);
  }

  /**
   * f0 -> < ARMY ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   * f3 -> ( UnitInstanceDefinition() )*<br>
   */
  @Override
  public void visit(final ArmyBuildEntries n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
    if (n.f3.present()) {
      processList(n.f3);
    }
  }

  /**
   * f0 -> < UNIT ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LCP ><br>
   * f4 -> ( UnitInstanceEntry() )*<br>
   * f5 -> < RCP ><br>
   */
  @Override
  public void visit(final UnitInstanceDefinition n) {
    n.f0.accept(this);
    n.f1.accept(this);
    if (n.f2.present()) {
      n.f2.accept(this);
    }
    n.f3.accept(this);
    if (n.f4.present()) {
      processList(n.f4);
    }
    n.f5.accept(this);
  }

  /**
   * f0 -> . %0 UnitInstanceSlotEntry()<br>
   * .. .. | %1 UnitInstanceCompositionEntry()<br>
   * .. .. | %2 UnitInstanceLinkedEntry()<br>
   * .. .. | %3 UnitInstanceUpgradesEntry()<br>
   * .. .. | %4 UnitMemberInstanceEntry()<br>
   */
  @Override
  public void visit(final UnitInstanceEntry n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> < TYPE ><br>
   * f1 -> Reference()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitInstanceTypeEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < SLOT ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitInstanceSlotEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < LINKED ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitInstanceLinkedEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < COMPOSITION ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitInstanceCompositionEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < UPGRADES ><br>
   * f1 -> Pattern()<br>
   * f2 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitInstanceUpgradesEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
  }

  /**
   * f0 -> < MEMBER ><br>
   * f1 -> Pattern()<br>
   * f2 -> [ #0 "$" #1 < IDENTIFIER > ]<br>
   * f3 -> < LP ><br>
   * f4 -> Pattern()<br>
   * f5 -> < RP ><br>
   * f6 -> < SEMICOLON ><br>
   */
  @Override
  public void visit(final UnitMemberInstanceEntry n) {
    n.f0.accept(this);
    n.f1.accept(this);
    if (n.f2.present()) {
      n.f2.accept(this);
    }
    n.f3.accept(this);
    n.f4.accept(this);
    n.f5.accept(this);
    n.f6.accept(this);
  }

  /**
   * f0 -> SetPatternExpr()<br>
   */
  @Override
  public void visit(final Pattern n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> AlternativeSetExpr()<br>
   * f1 -> ( #0 < COMMA > #1 AlternativeSetExpr() )*<br>
   */
  @Override
  public void visit(final SetPatternExpr n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> SinglePatternExpr()<br>
   * f1 -> ( #0 < OR > #1 SinglePatternExpr() )*<br>
   */
  @Override
  public void visit(final AlternativeSetExpr n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> . %0 SingleEntityPatternExpr()<br>
   * .. .. | %1 #0 < LP > #1 Pattern() #2 < RP ><br>
   * .. .. | %2 #0 < LB > #1 Pattern() #2 < RB ><br>
   */
  @Override
  public void visit(final SinglePatternExpr n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> [ Quantifier() ]<br>
   * f1 -> Reference()<br>
   * f2 -> [ #0 < FOR > #1 Expression() ]<br>
   */
  @Override
  public void visit(final SingleEntityPatternExpr n) {
    if (n.f0.present()) {
      n.f0.accept(this);
    }
    n.f1.accept(this);
    if (n.f2.present()) {
      n.f2.accept(this);
    }
  }

  /**
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 "*"<br>
   */
  @Override
  public void visit(final Quantifier n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> . %0 ConditionalExpression()<br>
   * .. .. | %1 LabeledExpression()<br>
   */
  @Override
  public void visit(final Expression n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> "#"<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> < LP ><br>
   * f3 -> ConditionalExpression()<br>
   * f4 -> < RP ><br>
   */
  @Override
  public void visit(final LabeledExpression n) {
    n.f0.accept(this);
    n.f1.accept(this);
    n.f2.accept(this);
    n.f3.accept(this);
    n.f4.accept(this);
  }

  /**
   * f0 -> LogicalOrExpression()<br>
   * f1 -> [ #0 "?" #1 Expression() #2 ":" #3 Expression() ]<br>
   */
  @Override
  public void visit(final ConditionalExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      n.f1.accept(this);
    }
  }

  /**
   * f0 -> LogicalAndExpression()<br>
   * f1 -> ( #0 "||" #1 LogicalAndExpression() )*<br>
   */
  @Override
  public void visit(final LogicalOrExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> EqualityExpression()<br>
   * f1 -> ( #0 "&&" #1 EqualityExpression() )*<br>
   */
  @Override
  public void visit(final LogicalAndExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> RelationalExpression()<br>
   * f1 -> ( #0 ( %0 "=="<br>
   * .. .. . .. | %1 "!=" ) #1 RelationalExpression() )*<br>
   */
  @Override
  public void visit(final EqualityExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> AdditiveExpression()<br>
   * f1 -> ( #0 ( %0 "<"<br>
   * .. .. . .. | %1 ">"<br>
   * .. .. . .. | %2 "<="<br>
   * .. .. . .. | %3 ">=" ) #1 AdditiveExpression() )*<br>
   */
  @Override
  public void visit(final RelationalExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> MultiplicativeExpression()<br>
   * f1 -> ( #0 ( %0 "+"<br>
   * .. .. . .. | %1 "-" ) #1 MultiplicativeExpression() )*<br>
   */
  @Override
  public void visit(final AdditiveExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> CollectionOperationExpression()<br>
   * f1 -> ( #0 ( %0 "*"<br>
   * .. .. . .. | %1 "/" ) #1 CollectionOperationExpression() )*<br>
   */
  @Override
  public void visit(final MultiplicativeExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> UnaryExpression()<br>
   * f1 -> ( #0 ( %0 < CONTAINS ><br>
   * .. .. . .. | %1 < UNION ><br>
   * .. .. . .. | %2 < INTERS ><br>
   * .. .. . .. | %3 < SELECT ><br>
   * .. .. . .. | %4 < EACH > ) #1 UnaryExpression() )*<br>
   */
  @Override
  public void visit(final CollectionOperationExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> . %0 #0 ( &0 "+"<br>
   * .. .. . .. .. | &1 "-" ) #1 UnaryExpression()<br>
   * .. .. | %1 UnaryExpressionNotPlusMinus()<br>
   */
  @Override
  public void visit(final UnaryExpression n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> . %0 #0 "!" #1 UnaryExpression()<br>
   * .. .. | %1 PrimaryExpression()<br>
   */
  @Override
  public void visit(final UnaryExpressionNotPlusMinus n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> ( %0 Literal()<br>
   * .. .. | %1 #0 < LP > #1 Expression() #2 < RP ><br>
   * .. .. | %2 Reference() )<br>
   * f1 -> ( #0 < ARROW > #1 AttributeSelector() )*<br>
   */
  @Override
  public void visit(final PrimaryExpression n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      processList(n.f1);
    }
  }

  /**
   * f0 -> . %00 < ARMY ><br>
   * .. .. | %01 < UNIT ><br>
   * .. .. | %02 < EQUIPMENT ><br>
   * .. .. | %03 < MEMBERS ><br>
   * .. .. | %04 < UPGRADES ><br>
   * .. .. | %05 < COST ><br>
   * .. .. | %06 < SLOTS ><br>
   * .. .. | %07 < TYPE ><br>
   * .. .. | %08 < UNITS ><br>
   * .. .. | %09 < LINKED ><br>
   * .. .. | %10 < IDENTIFIER ><br>
   */
  @Override
  public void visit(final AttributeSelector n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> . %0 < INTEGER_LITERAL ><br>
   * .. .. | %1 < STRING_LITERAL ><br>
   * .. .. | %2 BooleanLiteral()<br>
   * .. .. | %3 CollectionLiteral()<br>
   */
  @Override
  public void visit(final Literal n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> . %0 < TRUE ><br>
   * .. .. | %1 < FALSE ><br>
   */
  @Override
  public void visit(final BooleanLiteral n) {
    n.f0.accept(this);
  }

  /**
   * f0 -> < LCP ><br>
   * f1 -> [ #0 Expression()<br>
   * .. .. . #1 ( $0 < COMMA > $1 Expression() )* ]<br>
   * f2 -> < RCP ><br>
   */
  @Override
  public void visit(final CollectionLiteral n) {
    n.f0.accept(this);
    if (n.f1.present()) {
      n.f1.accept(this);
    }
    n.f2.accept(this);
  }

  /**
   * f0 -> [ "$" ]<br>
   * f1 -> < IDENTIFIER ><br>
   * f2 -> ( #0 "." #1 < IDENTIFIER > )*<br>
   */
  @Override
  public void visit(final Reference n) {
    if (n.f0.present()) {
      n.f0.accept(this);
    }
    n.f1.accept(this);
    if (n.f2.present()) {
      processList(n.f2);
    }
  }

}

/**
 * Stores a format command.
 */
class FormatCommand {

  /** Line break format code */
  public static final int FORCE = 0;
  /** Indentation format code */
  public static final int INDENT = 1;
  /** Unindentation format code */
  public static final int OUTDENT = 2;
  /** Spacing format code */
  public static final int SPACE = 3;

  /** The format command code */
  private int command;
  /** The format command repetition number */
  private int numCommands;

  /**
   * Constructor with class members.
   *
   * @param aCmd the command code
   * @param aNumCmd the command repetition number
   */
  FormatCommand(final int aCmd, final int aNumCmd) {
    this.command = aCmd;
    this.numCommands = aNumCmd;
  }

  /**
   * @return the command code
   */
  public int getCommand()  { return command; }

  /**
   * @return the command repetition number
   */
  public int getNumCommands()  { return numCommands; }

  /**
   * Sets the command code.
   *
   * @param i the command code
   */
  public void setCommand(final int i)  { command = i; }

  /**
   * Sets the command repetition number.
   *
   * @param i the command repetition number
   */
  public void setNumCommands(final int i)  { numCommands = i; }

}

/**
 * The TreeFormatter exception class.
 */
class TreeFormatterException extends RuntimeException {

  /** The serial version uid */
  private static final long serialVersionUID = 1L;

  /**
   * Constructor with no message.
   */
  TreeFormatterException()  { super(); }

  /**
   * Constructor with a given message.
   *
   * @param s the exception message
   */
  TreeFormatterException(final String s)  { super(s); }

}
